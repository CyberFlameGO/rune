+++
title = "This Month in Rune"
date = 2020-10-01
draft = true
template = "post.html"

[taxonomies]
categories = ["TMIR"]
tags = ["updates"]

[extra]
author = "John-John Tedro"
+++

Less then one month ago [I announced Rune on Reddit]. And the response so far
has been amazing.

In this post I'll detail the developments that have happened in the Language
since its initial announcement.

[I announced Rune on Reddit]: https://www.reddit.com/r/rust/comments/in67d3/introducing_rune_a_new_stackbased_dynamic/

<!-- more -->

## Modules and visibility

We've taught rune to expand modules and abide by visibility rules. This is a
nice feature that allows for encapsulation that brings Rune more in line with
Rust.

You can see basic modules in action with the following test case borrowed from
the [Rust reference book] (ignore the unused warnings ðŸ˜‰):

{% rune(footnote = "Basic modules and visibility smoke test", rune_config = '{"suppress_text_warnings": true}') %}
mod crate_helper_module {
    pub fn crate_helper() {}

    fn implementation_detail() {}
}

pub fn public_api() {}

pub mod submodule {
    use crate::crate_helper_module;

    pub fn my_method() {
        crate_helper_module::crate_helper();
    }

    fn my_implementation() {}

    mod test {
        fn test_my_implementation() {
            super::my_implementation();
        }
    }
}

pub fn main() {
    submodule::my_method();
}
{% end %}

This means that we've had to extend the existing module system, so that it
understands how to perform, detect, and *cache* recursive imports and visibility
checks. At this point it doesn't behave exactly like Rust. One example of this
is that conflicting wildcard imports simply override each other instead of
[being marked as ambiguous], as shown in this test case:

{% rune(footnote = "The last wildcard import wins") %}
mod a { pub struct Foo; }
mod b { pub struct Foo; }
use {a::*, b::*};
pub fn main() { Foo is b::Foo }
{% end %}

The behavior of modules is bound to be a bit buggy right now, and will probably
change in the future. So stay tuned!

[being marked as ambiguous]: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=3c0100d683d19c23168fa23e57483d2a
[Rust reference book]: https://doc.rust-lang.org/reference/visibility-and-privacy.html

## Macros

We've taught Rune how to parse and execute macros. Macros are compile-time
procedures which take one token stream and transforms it to produce another. The
produced token stream is added to the syntax tree of your program.

This is of course *a bit complicated*. You have to take care that macro
expansion happens in a manner that is well integrated into the rest of the
compilation. Too early, and the items produces in the macro for example can't
see imports. Too late, and it can't produce them. There are [still a few things]
that need to be figured out. But it's shaping up pretty well.

Rune support for macros is currently *experimental*. Macros are restricted to
only be allowed in native modules. This makes matters easier, because native
modules are written in Rust. And you get around the issue that you have to
compile the macro before it can be run. We've also learned a lot about macros
from Rust. Parsing in Rune has been designed in a way so that it can be re-used
within macros, similarly to what you get through the [`syn` crate]. We also
provide our own efficient version of the [`quote!` macro] to produce token
streams.

The following is an example macro that comes with the `std::experiments` crate.
It translates "stringy math" into rune expressions:

```rust
use rune::ast;
use rune::macros;
use rune::{quote, Parser, Spanned, TokenStream};
use runestick::SpannedError;

/// Implementation for the `stringy_math!` macro.
pub(crate) fn stringy_math(stream: &TokenStream) -> runestick::Result<TokenStream> {
    let mut parser = Parser::from_token_stream(stream);

    let mut output = quote!(0);

    while !parser.is_eof()? {
        let op = parser.parse::<ast::Ident>()?;
        let arg = parser.parse::<ast::Expr>()?;

        output = match macros::resolve(op)?.as_ref() {
            "add" => quote!((#output) + #arg),
            "sub" => quote!((#output) - #arg),
            "div" => quote!((#output) / #arg),
            "mul" => quote!((#output) * #arg),
            _ => {
                return Err(SpannedError::msg(
                    op.span(),
                    "unsupported operation",
                ).into())
            }
        }
    }

    parser.eof()?;
    Ok(output.into_token_stream())
}
```

You can try it out below:

{% rune(footnote = "Use of the stringy_math! macro", options = "macros=true", experimental = true) %}
use std::experiments::stringy_math;

pub fn main() {
    let value = stringy_math!(add 10 sub 5);
    println!("result: {}", value);
}
{% end %}

Macros are intended to be a blessed bedrock for language extension. To support
use-cases which can use a bit of custom syntax or behavior glued into a project.

[still a few things]: https://github.com/rune-rs/rune/issues/154
[`rune-experimental` crate]: https://docs.rs/rune-experimental
[`syn` crate]: https://docs.rs/syn/1
[`quote` macro]: https://docs.rs/quote/1
[Rocket]: https://rocket.rs

## constant evaluation

Work has been started to support *constant evaluation*. Usually all code is
compiled to target the [runestick virtual machine], but constant evaluation
introduces a separate interpreted mode that the compiler can run directly.

A limited subset of the language is currently available in constant contexts,
this includes functions and `const` items. Which can do the following:

* Numerical computations.
* Simple control flow through `if`, `while`, and `loop`.
* A number of binary operators.
* String operations and templates.
* ... and a bit more

Native functions are currently *not* visible during constant evaluation. This
could be enabled, but we still need to decide which scope to limit constant
evaluation to. I.e. do we want to be able to perform database requests during
constant evaluation? In practice this will probably be determined selectively.
Constant values are aggressively cached, so we should probably require a proof
obligation that they have no side effects and leave more complex uses with
potential side effects to macros.

Here's an example of what you can do today with constant evaluation:

{% rune(footnote = "Asynchronous programming using select", manually = true) %}
const fn greeting(name) {
    `Hello {name}`
}

/// Define a collection of predefined greetings.
const GREETINGS = [
    greeting("Stranger"),
    greeting("Jane"),
    greeting("John"),
    greeting("Mio"),
];

pub fn main() {
    let rng = rand::Pcg64::new();
    let greetings = GREETINGS;

	println(greetings[rng.int_range(0, greetings.len())]);
}
{% end %}

As a bonus, here's the [Fibonacci example used in the playground] as a constant
function. We only need to introduce `const` to the `fn` item for it to work.

{% rune(footnote = "Asynchronous programming using select", manually = true) %}
const fn fib(n) {
    if n <= 1 {
        n
    } else {
        fib(n - 1) + fib(n - 2)
    }
}

pub fn main() {
    fib(15)
}
{% end %}

[Fibonacci example used in the playground]: https://rune-rs.github.io/play/
[runestick virtual machine]: https://docs.rs/runestick/0

## `println!` and `FormatArgs`

In Rust, when you want to print something to stdout you can reach for the
`println!` macro.

```rust
println!("Hello {:>12}", "World");
```

The first argument in this macro is called a format string. And combined it
provides a convenient way for performing common text formatting operations in
Rust. Now Rune can also use a limited form of `println!`, and format arguments
in general.

{% rune(footnote = "Formatting with println!") %}
pub fn main() {
    println!("Hello {:>12}", "World");
}
{% end %}

To implement string formatting like this we've added `FormatArgs`, which is a
type that implements `Parse`, and can be used to conveniently add message
formatting to any macro. The full implementation of the `println!` macro above
is simply using it to format a string which is passed to `std::io::println`:

```rust
fn println_macro(stream: &TokenStream) -> Result<TokenStream> {
    let mut p = Parser::from_token_stream(stream);
    let args = p.parse_all::<macros::FormatArgs>()?;

    let expanded = args.expand()?;
    Ok(quote!(std::io::println(#expanded)).into_token_stream())
}
```

To accomplish this, `FormatArgs` is actually expanded into two internal macros:
* `#[builtin] template!(..)` which is the same macro produced by template
  strings.
* `#[builtin] format!(..)` which produces a `Format` value that conveniently
  implements the `string_display` protocol.

Strictly speaking, these are valid Rune. The `#[builtin]` attribute modifies how
the macros are looked up, so that they are solely expanded at compile time into
the appropriate instructions. These are intended for internal use only, but can
in fact be used. All though they will have no guarantee on stability:

{% rune(footnote = "Using the built-in template! and format! macros directly") %}
use std::io;

pub fn main() {
    io::println(#[builtin] template! {
        "Hello ",
        #[builtin] format! {
            "World",
            width = 12,
            align = right
        }
    });
}
{% end %}

This also means that the following macros now also support formatting:
* `panic!` to customize the panic message.
* `assert!` and `assert_eq!`.
* The newly introduced `format!`, which produces a string directly.

## Better iterator support

Iterators have gotten a bit of love in that they are now represented as a single
consistent type called `Iterator`. This holds all the iterators transformation
methods like `map`, `filter`, and `rev`. Any function producing an iterator
should produce an instance of `Iterator`.

{% rune(footnote = "Reversing an iterator") %}
struct Foo {
    value,
}

pub fn main() {
    let values = [1, "foo", Foo { value: 42 }];

    for v in values.iter().rev() {
        println!("{:?}", v);
    }
}
{% end %}

We've also added two collect functions, `collect_vec` and `collect_object`.

{% rune(footnote = "Apply filter to an iterator and collecting the result") %}
struct Foo {
    value,
}

pub fn main() {
    let values = [1, "foo", Foo { value: 42 }];

    values.iter().filter(|v| v is Foo).collect_vec()
}
{% end %}

> Why two functions? Well, Rune doesn't have [type annotations to select the
> desired output type]. This solution should be considered preliminary, because
> this might be a good case where [gradual typing] might be used in the future.

[type annotations to select the desired output type]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect
[gradual typing]: https://en.wikipedia.org/wiki/Gradual_typing

## IDE Support

Rune now has basic editor support in [rune-vscode]. A Visual Studio Code
extension that adds syntax highlighting and integration with the Rune language
server.

[rune-vscode]: https://marketplace.visualstudio.com/items?itemName=udoprog.rune-vscode

![Showcasing go to definitions](https://user-images.githubusercontent.com/111092/93017349-32a28f00-f5c8-11ea-9301-5fcb586c89c8.gif)

The language server is integrated with the same compiler as Rune. Our hope is to
be able to maintain the same compiler internals for all use cases, avoiding
duplication.

## Full Changelog

**include full changelog here**
